[["Map",1,2,9,10,18,19],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.7.13","content-config-digest","3442c6c1a8c27b48","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://rimzzlabs.com\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"vitesse-dark\",\"themes\":{},\"wrap\":true,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[null,null],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false},\"legacy\":{\"collections\":false}}","authors",["Map",11,12],"rimzzlabs",{"id":11,"data":13,"filePath":16,"digest":17},{"fullName":14,"username":11,"url":15},"Rizki Citra","https://rimzzlabs.com","src/content/authors/rimzzlabs.json","c62270d6f51eea0d","notes",["Map",20,21,45,46,76,77,91,92],"jotai-state-manager",{"id":20,"data":22,"body":42,"filePath":43,"digest":44,"deferredRender":40},{"title":23,"description":24,"keywords":25,"publishedAt":38,"status":39,"featured":40,"author":41},"Jotai, a beautiful state manager for React dev","When talked about state manager, the first word you could think would probably Redux, but for now let's use another state manager library, introducing Jotai.",[26,27,28,29,30,31,32,33,34,35,36,37],"react","hooks","jotai hooks","state mangement","react state management","jotai","jotai state manager","jotai react","jotai state","state","primitive state","primitive state management","07/08/2022","published",true,{"id":11,"collection":9},"## Introduction\n\nJotai is an awesome state manager for React, **No extra re-renders**, state resides within React, and you get the full benefits from suspense and concurrent features. It's scalable from a simple `React.useState` replacement to a large-scale application with complex requirements.\n\n> Jotai takes a bottom-up approach to React state management with an atomic model inspired by Recoil. One can build state by combining atoms and renders are optimized based on atom dependency. This solves the extra re-render issue of React context and eliminates the need for the memoization technique.\n\nA long time ago, I started to learn Frontend Web Development, and there is so much I could learn about, one of the most important topic in Frontend development is state management.\n\n## Using Jotai\n\nIn React, I can declare a state by using `useState`.\n\n```tsx\nconst [count, setCount] = useState(0);\n```\n\nBut the problem here is that when my app is getting bigger, I need to pass the state to the component props, otherwise using `React context` might be helpful.\n\nBut React context is not an _awesome_ solution for me, I need to wrap my components inside it's provider, which you may already know about **Provider Hell**, React context also make a re-render to my component everytime a state has changed.\n\nJotai on the other side is like a useState, I don't need to wrap my app with Provider, and it is also using atomic appproach, which is I've been using this approach lately _(components, style, services, etc.)_.\n\n### Declaring State in Store file\n\nIn Jotai, I can declare my app's state with atom.\n\n```ts title=\"@/store/atom.ts\" showLineNumbers\nimport { atom } from \"jotai\";\n\ntype User = {\n  username: string;\n  gender: \"male\" | \"female\";\n  website: string;\n};\n\nexport const userAtom = atom\u003CUser | null>(null);\n```\n\nAnd then I can use the state on my component.\n\n```tsx showLineNumbers\nimport { userAtom } from \"@/store/atom\";\n\nimport { useAtom } from \"jotai\";\n\nconst [user, setUser] = useAtom(userAtom);\n```\n\nThe user variable is containing user's data, otherwise `null` if there is no user logged in, so what's the `setUser` do?. Well setUser is just like `setState` in React, it's a function to modify it's state.\n\nJust like React setState, setUser can accept a function or a new state. I can replace the state with a new state, like this.\n\n```tsx showLineNumbers\nimport { userAtom } from \"@/store/atom\";\n\nimport { useAtom } from \"jotai\";\n\nconst [user, setUser] = useAtom(userAtom);\n\n// replace with newer state\nconst updateUser = () =>\n  setUser({ name: \"Foo\", gender: \"male\", website: \"foo.com\" });\n```\n\nOr maybe I just want to modify a certain properties. On this context, I've previously declared a **type User** which is an object containing property **name**, **gender** and **website**.\n\n```tsx showLineNumbers\nimport { userAtom } from \"@/store/atom\";\n\nimport { useAtom } from \"jotai\";\n\nconst [user, setUser] = useAtom(userAtom);\n\n// modify only name property\nconst updateUser = () =>\n  setUser((prevState) => ({ ...prevState, name: \"FooBizz\" }));\n```\n\nOn `updateUser` function, I modify the name property with **FooBizz**, that's the basic usage with Jotai.\n\nSee? it's just like a regular useState, and also I can use the User state in another component, cool, right?ðŸ˜Ž.\n\n### Persistent State\n\nSometimes when I refreshed my browser, my app's state is also got refreshed, but I want to keep my state, the solution here is persistent state.\n\nJotai comes with battery-packed utilities, for example `atomWithStorage` not only holds my state but also saved my state on localStorage, this is called a persistent state because I can save my state on localStorage, when I modify my state, it will also update my state on the localStorage.\n\nThis is very useful for a state that need to be hold on localStorage like **Theme**.\n\n```tsx {2,9,13-14} title=\"@/store/atom.ts\" showLineNumbers\nimport { atom } from \"jotai\";\nimport { atomWithStorage } from \"jotai/utils\";\n\ntype User = {\n  username: string;\n  gender: \"male\" | \"female\";\n  website: string;\n};\ntype Theme = \"dark\" | \"light\";\n\nexport const userAtom = atom\u003CUser | null>(null);\n\n// atomWithStorage(localStorage key, initial value)\nexport const themeAtom = atomWithStorage\u003CTheme>(\"theme\", \"light\");\n```\n\nI'm exporting a new atom state with `atomWithStorage()` utility. This function accept 3 arguments, the first two is required, the last one is optional, the first argument is the localStorage key, and the second argument is the initial value set to it's state.\n\nBut how can I use this state? well again, I can read and modify the state just like regular useState.\n\n```tsx showLineNumbers\nimport { themeAtom } from \"@/store/atom\";\n\nimport { useAtom } from \"jotai\";\n\nconst [theme, setTheme] = useAtom(themeAtom);\n```\n\n## Comparison to Another Library\n\nLet's compare Jotai to another library, this comparison is based on Jotai official website.\n\n### Jotai vs Zustand\n\nJotai is like Recoil. while [Zustand](https://github.com/pmndrs/zustand \"Zustand Repository\") is like Redux.\n\nThe major difference is the state model. Zustand is a single store (although you could create multiple separate stores), while Jotai consists of primitive atoms and allows composing them together. In this sense, it's the matter of programming mental model.\n\nJotai can be a replacement for useState+useContext. Instead of creating multiple contexts, atoms share one big context.\n\nZustand is an external store and the hook is to connect the external world to the React world.\n\n#### When to Switch\n\n- If you need a replacement for useState+useContext, Jotai fits well.\n- If you want to update state outside React, Zustand works better.\n- If code splitting is important, Jotai should perform well.\n- If you prefer Redux devtools, Zustand is good to go.\n- If you want to make use of Suspense, Jotai is the one.\n\n### How is Jotai Different from Recoil?\n\n#### Developer\n\n- Jotai is developed with collective work by a few developers in Poimandres (formerly react-spring) org.\n- Recoil is developed by a team at Facebook.\n\n#### Basis\n\n- Jotai is focusing on primitive APIs for easy learning, and it's unopinionated. (The same philosophy with Zustand)\n- Recoil is full featured for big apps with complex requirements.\n\n#### Techincal Difference\n\n- Jotai depends on atom object referential identities.\n- Recoil depends on atom string keys.\n\n#### When to Use Which\n\n- If you want to learn something new, either should work.\n- If you like Zustand, Jotai would also be pleasant.\n- If your app heavily requires state serialization (storing state in storage, server, or URL), Recoil comes with good features.\n- If you need React Context alternatives, Jotai comes with enough features.\n- If you would try to create a new library, Jotai might give good primitives.\n- Otherwise, both are pretty similar about the general goals and basic techniques.\n\n## Using it with React\n\nI can store my app's state on every component, but I can also create a store on a separated file, I prefer create a new file inside store folder, for example.\n\n```tsx title=\"@/store/atom.ts\" showLineNumbers\nimport { atom } from \"jotai\";\nimport { atomWithStorage } from \"jotai/utils\";\n\ntype Theme = \"light\" | \"dark\";\ntype User = {\n  name: string;\n  gender: \"male\" | \"female\";\n  website: string;\n};\n\nexport const userAtom = atom\u003CUser | null>(null);\n\nexport const themeAtom = atomWithStorage\u003CTheme>(\"theme\", \"light\");\n```\n\n### Read and Modify State\n\nI could read and modify the state on every component like this.\n\n```tsx title=\"@/components/DarkModeToggle.tsx\" showLineNumbers\nimport * as atoms from \"@/store/atom\";\n\nimport { useAtom } from \"atom\";\n\nexport default function DarkModeToggle() {\n  const [theme, setTheme] = useAtom(atoms.themeAtom);\n\n  const toggleTheme = setTheme((prev) => (prev === \"light\" ? \"dark\" : \"light\"));\n\n  return \u003Cbutton onClick={toggleTheme}>Current theme is {theme}\u003C/button>;\n}\n```\n\nBut I prefer to create a custom hooks instead, for example, to manage my theme state, I could create a custom hooks to switch between dark mode and light mode.\n\n```tsx title=\"@/hooks/useDarkMode.ts\" showLineNumbers\nimport * as atoms from \"@/store\";\n\nimport { useAtom } from \"jotai\";\nimport { useEffect } from \"react\";\n\nconst useDarkMode = () => {\n  const [theme, setTheme] = useAtom(atoms.themeAtom);\n\n  const toggleTheme = () =>\n    setTheme((prev) => (prev === \"light\" ? \"dark\" : \"light\"));\n\n  useEffect(() => {\n    document.documentElement.className = theme;\n    document.documentElement.style.colorScheme = theme;\n  }, [theme]);\n\n  return { theme, toggleTheme };\n};\n\nexport default useDarkMode;\n```\n\nAnd then I could refactor the above component which is **DarkModeToggle** to be like this:\n\n```tsx {4,6} title=\"@/components/DarkModeToggle.tsx\" showLineNumbers\nimport useDarkMode from \"@/hooks/useDarkMode\";\n\nexport default function DarkModeToggle() {\n  const { theme, toggleTheme } = useDarkMode();\n\n  return \u003Cbutton onClick={toggleTheme}>Current theme is {theme}\u003C/button>;\n}\n```\n\nSee, very simple right? oh and you could read the complete documentation of Jotai [Here](https://jotai.org \"Jotai official website\").\n\nThe core concept and API reference are very easy to learn, also checkout this [free course's](https://egghead.io/courses/manage-application-state-with-jotai-atoms-2c3a29f0 \"Jotai free course\") Jotai provided.\n\nSo that's it folks, thank you so much for reading my blog and I hope you gain more insight about Jotai after reading this blog, see you next timeðŸ‘‹.","src/content/notes/jotai-state-manager.mdx","4295e03b08536e37","improving-performance-in-react",{"id":45,"data":47,"body":73,"filePath":74,"digest":75,"deferredRender":40},{"title":48,"description":49,"keywords":50,"publishedAt":70,"status":39,"featured":71,"author":72},"Improving Performance in React with These 3 Techniques","A slow or unresponsive app can frustrate users and lead to a poor user experience. In today's competitive market, it's more important than ever to ensure that your app is delivering the best possible experience to your users.",[51,26,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69],"improve performance","react.js","performance","code-splitting","react app","lazy","loading","lazy loading","react performance","code splitting react app","vitejs","memoization","usememo","usecallback","React.memo","React.useCallback","React.useMemo","memoization in react","improving performance in react app","12/25/2022",false,{"id":11,"collection":9},"## Introduction\n\n> Long read, take a nice seat and enjoy ðŸ».\n\nReact.js is a popular JavaScript library for building user interfaces, known for its flexibility and performance. With React.js, you can create reusable components that make it easy to build and maintain complex applications.\n\n> Hi there! I wanted to recommend that you can try out the live code examples while reading this blog post. Go ahead and continue on with the post! Cheers âœŒï¸.\n\nIt was created by Facebook and has since become one of the most popular choices for front-end development, thanks to its ability to handle complex and dynamic applications with ease.\n\nIn a React.js app, components are the building blocks that make up the user interface. They can be composed together to create a hierarchical tree of components, with the root component representing the entire app.\n\nWhen a component's state or props _(short for properties)_ change, React.js efficiently updates the DOM to reflect these changes. This helps to make React.js apps fast and responsive, even when dealing with large amounts of data.\n\nHowever, as the complexity and scale of a React.js app grow, developers need to take steps to optimize its performance. This might include techniques like `**code-splitting**, which helps to reduce the size of the initial bundle that is loaded by the browser and **memoization**, which helps to improve the efficiency of function calls by caching their results.\n\nIn this blog post, we'll be covering things like **code-splitting**, memoization with `React.memo`, `React.useMemo`, and `React.useCallback`. Whether you're new to React.js or an experienced developer looking to take your app's performance to the next level, this post might suit you.\n\n## Optimizing Performance\n\nWhen it comes to building web applications, performance is critical. A slow or unresponsive app can frustrate users and lead to a poor **user experience**. In today's competitive market, it's more important than ever to ensure that your app is delivering the best possible experience to your users.\n\nBut performance _isn't just about user satisfaction_. It can also have a direct impact on your business. For example, if your app takes too long to load, users may abandon it before it even has a chance to show them what it can do. This can lead to lost customers and revenue. On the other hand, a fast and responsive app can help to keep users engaged and more likely to return.\n\nPerformance is still an important consideration for any web application. Here are just a few reasons why you should care about the performance of your React.js app:\n\n- **User Experience:** A slow or unresponsive app can be frustrating for users, which can lead to them abandoning the app altogether. On the other hand, a fast and smooth app can improve the user's overall experience and keep them coming back for more.\n\n- **SEO:** In today's digital landscape, your website or app needs to rank well in search engine results. One factor that can affect your ranking is the loading speed of your site. If your React.js app is slow to load, it could hurt your search engine ranking and make it harder for users to find your app.\n\n- **Conversion Rates:** A slow app can also impact your business's bottom line. Studies have shown that faster loading times can lead to higher conversion rates, meaning more users taking the desired action (such as making a purchase).\n\n- **Scalability:** As your React.js app grows in complexity and scale, it's important to ensure that it can handle the increased load. Optimizing the performance of your app can help to ensure that it remains stable and scalable as it grows.\n\nIn short, optimizing the performance of your React.js app is important for both user satisfaction and the success of your business. In the following sections, we'll be exploring advanced techniques for doing just that.\n\n## Code-Splitting\n\nCode-splitting is a technique that allows developers to split their code into smaller, more manageable chunks or bundles. These bundles can then be loaded on demand, rather than all at once when the app first loads.\n\nThis can help to improve the performance of a React.js app by reducing the size of the initial bundle that the browser has to download, which can make the app load faster.\n\nCode-splitting is particularly useful for larger, more complex apps that have a lot of code, as it allows developers to break the code up into smaller pieces that can be loaded as needed. This can help to reduce the overall size of the app, which can improve its performance and make it easier to maintain.\n\nThere are several ways to implement code-splitting in a React.js app, such as using the `React.lazy` and `React.Suspense` components, or using a tool like [Vite.js](https://vitejs.dev).\n\n### Suspensing Component\n\nTo implement code splitting in your React application, you can use `React.lazy` and `React.suspense`.\n\n`React.lazy` allows you to dynamically import a component so that it is only loaded when it is needed. This is done using the `import()` function, which returns a promise that resolves to the module that you are importing.\n\n`React.suspense` is a higher-order component that you can use to wrap a dynamic import in a `\u003CSuspense>` component. This will display a fallback component while the code for the dynamically imported component is being loaded.\n\nHere's an example of how you might use `React.lazy` and `React.Suspense` in your application:\n\n```tsx title=\"App.tsx\" showLineNumbers\nimport { Suspense, lazy } from \"react\";\n\nconst MyComponent = lazy(() => import(\"./MyComponent\"));\n\nexport default function App() {\n  return (\n    \u003CSuspense fallback={\u003Cdiv>Loading...\u003C/div>}>\n      \u003CMyComponent />\n    \u003C/Suspense>\n  );\n}\n```\n\nIn this example, the `MyComponent` component will not be loaded until it is needed, and the fallback component will be displayed while the code for `MyComponent` is being loaded. This can help improve the performance of your application by only loading the code that is needed.\n\n### Bundling with Vite.js\n\n> To Read more about Vite.js, please [follow this link about Vite.js](https://vitejs.dev/guide)\n\nIn addition to using `React.lazy` and `React.suspense`, another way to implement code splitting in your React application is by using a tool called Vite.js as your frontend tooling.\n\nVite.js is a lightweight, simple, and fast-build tool that is designed specifically for modern JavaScript applications. It uses Rollup under the hood, which means that you can use all of the same code-splitting techniques that you would use with Rollup in your Vite.js projects.\n\nOne of the benefits of using Vite.js for code splitting is that it allows you to easily split your code into different chunks, including splitting vendors' code from your code. This can help improve the performance of your application by only loading the code that is needed at a given moment, rather than loading everything up upfront.\n\nLet's split vendors' code from our code, take a look at this code:\n\n```ts title=\"vite.config.ts\" showLineNumbers\nimport { dependencies } from \"./package.json\";\n\nconst exclVendors = [\"react\", \"react-router-dom\", \"react-dom\"];\nfunction renderChunks(deps: Record\u003Cstring, string>) {\n  let chunks = {};\n  Object.keys(deps).forEach((key) => {\n    if (exclVendors.includes(key)) return;\n    chunks[key] = [key];\n  });\n  return chunks;\n}\n// https://vitejs.dev/config/\nexport default defineConfig({\n  build: {\n    sourcemap: false,\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          ...renderChunks(dependencies),\n        },\n      },\n    },\n  },\n});\n```\n\nIn this code, the `renderChunks` function is being used to create an object with keys for each dependency, and values that include the dependency name. This allows you to create a chunk for each dependency, which can then be code split.\n\nYou may have noticed that in the code provided, there is an array of excluded vendors. This array is used to specify which dependencies should not be included in the code-splitting process.\n\nIn this case, the array includes `react`, `react-router-dom`, and `react-dom`, which are core dependencies of React that are not included in the code-splitting process. This is because these dependencies are likely to be used throughout your application, and it may not be beneficial to split them into separate chunks.\n\nHowever, the rest of the dependencies are added to the `rollupOptions` object, which is used to configure the code-splitting process. These dependencies will be split into separate chunks and loaded on demand, rather than all at once. This can help improve the performance of your application by only loading the code that is needed at a given moment.\n\nOverall, by excluding certain dependencies from the code splitting process and adding the rest to the `rollupOptions` object, you can effectively set up code splitting in your Vite.js project and improve the performance of your React.js application.\n\nWhat types of components should I use `React.lazy` with, and what types of components should I not lazy load?\n\nThere are a few types of components that are good candidates for code-splitting with `React.lazy`. For example, if I have a feature that's only used on one page of my application, I might consider code-splitting that feature into a separate chunk that only gets loaded when the user navigates to that page.\n\nHere are some types of components that are good candidates for code-splitting with `React.lazy`:\n\n- Components that are only needed in specific routes or areas of the application. For example, if you have a feature that is only used on one page of your application, you might consider code-splitting that feature into a separate chunk that is only loaded when the user navigates to that page.\n- Components that are large or complex, and may take a long time to load. Splitting these components into smaller chunks can help reduce the initial load time of your application.\n- Components that are used infrequently or by a small number of users. In these cases, code-splitting can help reduce the overall size of your application and improve its performance for the majority of users.\n\nOn the other hand, some types of components may not be good candidates for code-splitting with `React.lazy`:\n\n- Components that are needed immediately on initial load. If a component is critical to the initial rendering of your application, it may not be a good candidate for code-splitting, as the user would have to wait for it to be loaded before the application can be used.\n- Components that are small and simple, and may not provide significant performance benefits when code-split. In these cases, it may be more efficient to leave the component in the main bundle and avoid the overhead of dynamically importing it.\n\nIn general, it's a good idea to carefully evaluate the trade-offs of code-splitting when deciding which components to split. Code-splitting can be a powerful tool for improving the performance of a React application, but it's important to carefully consider the specific needs of your application before implementing it.\n\n## Memoization\n\nSo, memoization is a technique that helps speed up your app by storing the results of expensive function calls and returning them when the same inputs come up again. This can be especially useful for functions that get called a lot with the same arguments since it saves time by not having to recalculate the result every time.\n\nIn the case of React, memoization can be used to make functional components run more efficiently. By default, React will re-render a functional component whenever the component's props or state changes. This can be a problem if the component gets called a lot with the same props since it will cause unnecessary re-renders. Memoization can help solve this issue by \"memoizing\" the component and only re-rendering it if the props have changed.\n\nThere are a few different ways you can use memoization in a React app. One option is to use the `React.useMemo` hook, which is a built-in React feature that lets you memoize a value. And then there is `React.useCallback` hook, which is a built-in React feature, but this hook will memoize a function instead of a value. Last but not least, there is `React.memo` which is a also built-in React feature, but the difference here is not a function but a _Higher Order Components_ that let you memoize a component.\n\nMemoization is like caching on your React.js app, here are a few reasons why memoization can be important in a React.js app:\n\n- **Improved performance**: As mentioned earlier, memoization can help improve the performance of your app by avoiding unnecessary re-renders of functional components. This can be especially useful for components that are called frequently with the same props, as it can save a lot of time and resources by avoiding the need to recalculate the component's result.\n\n- **Improved user experience**: By optimizing the performance of your app, you can improve the overall user experience. Faster loading times and smoother transitions between screens can make your app feel more responsive and enjoyable to use.\n\n- **Reduced complexity**: Memoization can also help reduce the complexity of your code by allowing you to write simpler, more declarative components. Without memoization, you might have to write more complex logic to avoid unnecessary re-renders, which can make your code harder to understand and maintain.\n\n### React.useMemo\n\nThe useMemo hook is a built-in React hook that allows you to memoize a value. It takes a function as an argument and **returns a memoized version** of the value returned by that function.\n\nThe memoized value is **only recomputed if one of the dependencies listed in the second argument to the hook has changed**. This can be useful for optimizing the performance of functional components by avoiding unnecessary recalculations of expensive values.\n\nTake a look at this basic syntax for the `React.useMemo` hook:\n\n```tsx\nconst value = useMemo(() => computedExpensiveValue(buzz, fizz), [buzz, fizz]);\n```\n\nIn this example, the `computedExpensiveValue` function is called with arguments `buzz` and `fizz`, and **the result is memoized**. The memoized value **will only be recomputed if the values of `buzz` or `fizz` change**.\n\nAnother example to use `React.useMemo` is for filtering and sorting large data sets: Let's say you have a list of products that you want to display in a component, and you want to allow the user to filter and sort the list based on various criteria. You could use the `useMemo` hook to memoize the filtered and sorted version of the list, like so:\n\n```tsx title=\"@/components/product-list.tsx\" showLineNumbers\nimport { useMemo } from \"react\";\n\nexport const ProductList = ({ products, filter, sortBy }) => {\n  // Memoize the filtered and sorted version of the product list\n  const filteredAndSortedProducts = useMemo(() => {\n    // Filter the products based on the filter criteria\n    let filteredProducts = products;\n    if (filter) {\n      filteredProducts = filteredProducts.filter((product) =>\n        product.name.includes(filter)\n      );\n    }\n    // Sort the products based on the sortBy criteria\n    return filteredProducts.sort((a, b) => a[sortBy] > b[sortBy]);\n  }, [products, filter, sortBy]);\n\n  return (\n    \u003Cul>\n      {filteredAndSortedProducts.map((product) => (\n        \u003Cli key={product.id}>{product.name}\u003C/li>\n      ))}\n    \u003C/ul>\n  );\n};\n```\n\nIn this example, the `ProductList` component filters and sorts the products list based on the filter and `sortBy` props, and stores the result in a memoized value. This can help to improve the performance of the component by **avoiding unnecessary recalculations** of the filtered and sorted list every time the component re-renders.\n\n### Don't useMemo everything\n\n`React.useMemo` is a hook that allows you to optimize the performance of your functional components by memoizing values that are expensive to compute. But there are a few situations where it might not be the best choice:\n\n- If the value you're computing is _super simple_ or _cheap to compute_, then it might not be worth the extra overhead of using `React.useMemo`. In these cases, the performance boost might not be worth the extra code.\n\n- If the value you're computing is only used once or a few times in the component, then it might not be worth the extra overhead of using `React.useMemo`. In these cases, the performance boost might not be significant enough to justify the extra code.\n\n- If the value you're computing depends on props that change very frequently, then `React.useMemo` might not be able to keep up with the changes and you could end up with stale data. In these cases, you might want to consider using a different optimization technique, like `React.useEffect` or `React.useReducer`, to **avoid unnecessary re-computations**.\n\n`React.useMemo` is a good way to improve your React app performance, but if the value you're computing is super simple or cheap to compute, if it's only used a few times in the component, or if it depends on frequent changing props. But in most other cases, `React.useMemo` can be a really useful way to optimize the performance of your functional components.\n\n## React.useCallback\n\nThe `useCallback` hook is a built-in React hook that allows you to create a memoized version of a callback function. It takes a function as an argument and an array of dependencies and **returns a memoized version of the function that only changes if one of the dependencies has changed**.\n\nThis can be useful for optimizing the performance of functional components **by avoiding unnecessary re-creations** of callback functions.\n\nTake a look at this basic syntax of the `useCallback` hook:\n\n```tsx showLineNumbers\nconst callback = useCallback(() => {\n  doSomething(longitude, latitude);\n}, [longitude, latitude]);\n```\n\nIn this example, the callback function is created using the `useCallback` hook, and it will **only be re-created if the values of `longitude` or `latitude` change**.\n\nAnother example to use `React.useCallback` is by passing callbacks to deeply nested components. If you have a complex component hierarchy and you want to pass a callback function down to a child component, you can use the `useCallback` hook to avoid unnecessary re-creations of the callback function. This can help improve the performance of your app by avoiding unnecessary re-renders of the child component.\n\nLet's say you have a parent component that renders a list of items, and each item has a delete button that calls a delete callback when clicked. You could use the `useCallback` hook to create a memoized version of the delete callback and pass it down to the child component like this:\n\n```tsx title=\"@/components/parent-component.tsx\" showLineNumbers\nimport { useCallback } from \"react\";\n\nconst ParentComponent = ({ items, onDelete }) => {\n  // Create a memoized version of the onDelete callback\n  const handleDelete = useCallback(\n    (itemId) => {\n      onDelete(itemId);\n    },\n    [onDelete]\n  );\n\n  return (\n    \u003Cul>\n      {items.map((item) => (\n        \u003CChildComponent key={item.id} item={item} onDelete={handleDelete} />\n      ))}\n    \u003C/ul>\n  );\n};\n```\n\nIn this example, the `ParentComponent` function component renders a list of ChildComponent components and passes each component a callback function for deleting items. The `useCallback` hook is used to create a memoized version of the callback function, which helps improve the performance of the `ParentComponent` component by **avoiding unnecessary re-creations of the function**. The `ChildComponent` components can then use the callback function to delete the corresponding item when the delete button is clicked.\n\nThere are a few situations where it might not be the best choice to use this hook, here are a few reasons why:\n\n- If the callback function is super simple or cheap to create, then it probably doesn't make sense to use `React.useCallback`. The extra overhead might not be worth it in these cases.\n\n- If the callback function is only used a few times in the component, then it might not be worth using `React.useCallback`. The performance boost might not be significant enough in these cases.\n\n- If the callback function depends on props that change very frequently, then `React.useCallback` might not be able to keep up with the changes and you could end up with a stale function. In these cases, you might want to consider using a different optimization technique.\n\n## React.memo\n\n`React.memo` is a way to optimize the performance of functional components in React by **preventing them from re-rendering unnecessarily**. It does this by **\"memoizing\"** the component, which means that it only re-renders the component if the props have actually changed.\n\nHere's an example of how you might use `React.memo`:\n\n```tsx title=\"@/components/my-component.tsx\" showLineNumbers\nimport { memo } from \"react\";\n\nconst MyComponent = ({ name }) => {\n  console.log(\"Render MyComponent\");\n  return \u003Cdiv>Hello, {name}!\u003C/div>;\n};\n\nexport default memo(MyComponent);\n```\n\nIn this example, the `MyComponent` component renders a greeting with the name prop. By wrapping the component with `React.memo`, you can tell React to only re-render the component if the name prop has hanged. This can help improve the performance of your app by avoiding unnecessary re-renders of the component.\n\nYou can use `React.memo` to optimize the performance of any functional component that doesn't need to re-render every time its props change. It's a simple and effective way to improve the performance of your React app.\n\nBasically, `React.memo` is a way to optimize the performance of functional components by **avoiding unnecessary re-renders**. But there are a few situations where it might not be the best choice:\n\n- If the component does not have any expensive calculations or props _(e.g. large `objects` or `arrays`)_, then there may not be much of a performance benefit to using `React.memo`. In these cases, the overhead of using `React.memo` might be slower than just re-rendering the component.\n\n- If the component has a lot of states or props, then using `React.memo` might actually make the component slower, as the HOC has to compare all of the states and props on every update. In these cases, it might be more efficient to use the `React.useMemo` hook or the `React.useReducer` hook to optimize the component's performance.\n\n- If the component updates very frequently _(e.g. on every tick of a timer)_, then using `React.memo` might not be efficient, as the _HOC_ has to compare the previous and current props on every update. In these cases, it might be more efficient to use a class component or the `React.useReducer` hook to optimize the component's performance.\n\nI hope this helps give you a sense of when you might or might not want to use `React.memo` to optimize the performance.\n\n## Closing\n\nWe've looked at several techniques for optimizing the performance of a React.js app, including memoization, code-splitting, and more. By using these techniques, you can improve the performance of your app and provide a better experience for your users.\n\nHere are a few additional tips for optimizing the performance of your React.js app:\n\n- Use the [React Developer Tools](https://beta.reactjs.org/learn/react-developer-tools \"react dev tools browser extension link\") browser extension to profile your app and identify performance bottlenecks.\n\n- Consider using a performance monitoring tool like [LogRocket](https://logrocket.com/ \"log rocket official website\") to track the performance of your app over time.\n\n- Consider using a state management like [Jotai](https://jotai.org \"Jotai official website\") or [Zustand](https://docs.pmnd.rs/zustand/getting-started/introduction \"Zustand official documentation website\") to easily manage your app's state.\n\nThank you for reading this blog post! I hope you found it helpful. See you in my next post!","src/content/notes/improving-performance-in-react.mdx","ad6cfd33081357ce","jotai-recipes",{"id":76,"data":78,"body":88,"filePath":89,"digest":90,"deferredRender":40},{"title":79,"description":80,"keywords":81,"publishedAt":86,"status":39,"featured":40,"author":87},"Jotai Recipes I Commonly Use for My Project","To read and modify state on our application with Jotai, we need to use paradigm called Recipes, now lets see how we can utilize those terms to read and modify our state with Jotai",[26,31,27,82,83,84,85],"jotai recipes","reactjs","state management","state manager","09/30/2023",{"id":11,"collection":9},"## Introduction\n\nJotai takes an atomic approach to global React state management. By combining atoms and renders are automatically optimized based on atom dependency.\n\nThis solves the extra re-render issue of React context, eliminates the need for memoization, and provides a similar developer experience to signals while maintaining a **_declarative programming model_**.\n\n> If you don't know about Jotai, I have a [post about jotai](/notes/jotai-state-manager) explained you can read, feel free to check it out!\n\nTo update a state with Jotai, I can simply use built-in Jotai `setter` like so:\n\n```tsx showLineNumbers title=\"app.tsx\"\nimport { atom, useAtom } from \"jotai\";\n\nconst atomFruit = atom(\"mango\");\n\nexport default function App() {\n  const [fruit, setFruit] = useAtom(atomFruit);\n\n  return \u003Cbutton onClick={() => setFruit(\"orange\")}>{fruit}\u003C/button>;\n}\n```\n\nJust a basic usage with Jotai, pretty simple.\n\n## Derived Value\n\nBefore coming to know what _recipes_ are in Jotai, we first should know about a derived or computed value.\n\nA derived or computed value is a value obtained from other existing value through some logic, transformation, or calculation.\n\nIn programming, a derived or computed values are often used to simplify code, it used to encapsulate logic, and make data manipulation based on existing value to be more convenient.\n\n```tsx title=\"App.tsx\" showLineNumbers\nexport default function App() {\n  const { user } = useUser();\n  const isUserAdmin = user.role === \"admin\";\n\n  if (isUserAdmin) {\n    return \u003Cp>You are admin\u003C/p>;\n  }\n\n  return \u003Cp>Just a normal user\u003C/p>;\n}\n```\n\nIn the above example we check wether the user is admin or not, if it's admin, the component simply render **\"You are admin\"**, otherwise it render **\"Just a normal user\"**.\n\nThe condition to render different UI to the client is by using a derived value `isUserAdmin`.\n\nOh wow! we already use a `derived` value here.\n\n## Derived Atoms\n\nLet's move on to derived atoms. Derived atoms are just same as the previous one, we just need to see what the previous values are, and then make some magic to process with the current logic or calculation.\n\n```ts title=\"@/atoms.ts\" showLineNumbers\nimport { atom } from \"jotai\";\n\ntype TUserRole = \"admin\" | \"user\";\ntype TUser = {\n  name: string;\n  role: Role;\n};\n\nconst userAtom = atom\u003CTUser>({ name: \"Rizki\", role: \"user\" });\n\nconst isUserAdminAtom = atom((get) => get(userAtom).role === \"admin\");\n```\n\nThe above example shows how to create a derived value from the previous atom, very similiar from what we wrote before with `React.useState`.\n\nIn Jotai, It's called recipes, we can compose atoms to another atoms, or create an atoms based on the previous atoms to make a new value or atom.\n\nJotai allows to create these derived values using a declarative approach and without needing to explicitly manage complex state relationships.\n\n## Recipes\n\nRecipes are just derived atoms, a derived atoms usually consist of two principle.\n\nA `read-only` atom takes another atom as input and transforms its value through a calculation performed by a function. This changed value can be used to indicate a computation or modification of the value of the original atom as a derived value.\n\nA `write-only` atoms serve the purpose of accepting new values through writing mechanisms, like `callbacks`. These new values can then be used to trigger specific actions or update an atom in your `write-only` atom.\n\nNow you know about these terms, let's create some recipes.\n\n### 0. Compose Recipes\n\nComposing atoms is a way to transform atoms with multiple function calls; the returned value should be predictable and have no side effects.\n\n```ts title=\"@/atoms/compose.ts\" showLineNumbers\nimport type { PrimitiveAtom } from \"jotai\";\n\ntype ComposeAtomFn\u003CT> = (value: PrimitiveAtom\u003CT>) => PrimitiveAtom\u003CT>;\n\nexport function composePrimitiveAtom\u003CT>(...fns: Array\u003CComposeAtomFn\u003CT>>) {\n  return (value: PrimitiveAtom\u003CT>) => {\n    return fns.reduce((currentValue, fun) => fun(currentValue), value);\n  };\n}\n```\n\n### 1. Boolean Recipes\n\nSwitch! Who doesn't need boolean? Everyone needs boolean value, so let's create boolean recipes.\n\nFirst, we usually manage a boolean value with React. useState to handle an open or closed state, such as a sidebar or dialog. But what if it can be well-baked with Jotai?.\n\n```ts title=\"@/atoms/boolean.ts\" showLineNumbers\nimport type { PrimitiveAtom } from \"jotai\";\n\nexport function openAtom(boolAtom: PrimitiveAtom\u003Cboolean>) {\n  return atom(null, (_, set) => set(boolAtom, true));\n}\n\nexport function closeAtom(boolAtom: PrimitiveAtom\u003Cboolean>) {\n  return atom(null, (_, set) => set(boolAtom, false));\n}\n\nexport function toggleAtom(boolAtom: PrimitiveAtom\u003Cboolean>) {\n  return atom(null, (get, set) => set(boolAtom, !get(boolAtom)));\n}\n```\n\nWith that snippet, we can create each handler to manage our `open/closed` state.\n\n```ts title=\"@/atoms/sidebar.ts\" showLineNumbers\nimport { openAtom, closeAtom, toggleAtom } from \"@/atoms/boolean\";\n\nimport { atom } from \"jotai\";\n\nexport const sidebarAtom = atom(false);\nexport const openSidebarAtom = openAtom(sidebarAtom);\nexport const closeSidebarAtom = closeAtom(sidebarAtom);\nexport const toggleSidebarAtom = toggleAtom(sidebarAtom);\n```\n\nNow let me explain about those codes: `openSidebarAtom`, `closeSidebarAtom`, and `toggleSidebarAtom` are actually a `write-only` atoms, meaning it's actually handlers to mutate our `sidebarAtom`, in Jotai style.\n\nNow let's see how we can use those fancy atoms.\n\nOn our sidebar component, this sidebar can observe the `sidebarAtom` value and render the UI accordingly. But it can also close the sidebar itself.\n\n```tsx title=\"@/components/sidebar.tsx\" showLineNumbers\nimport { sidebarAtom, closeSidebarAtom } from \"@/atoms/sidebar\";\n\nimport { Drawer } from \"@mantine/core\";\nimport { useAtomValue, useSetAtom } from \"jotai\";\n\nexport function Sidebar() {\n  const isSidebarOpen = useAtomValue(sidebarAtom);\n  const closeSidebar = useSetAtom(closeSidebarAtom);\n\n  return \u003CDrawer opened={isSidebarOpen} onClose={closeSidebar} />;\n}\n```\n\nThen, on our button component that triggers the `open/closed` state of the sidebar, the button may be placed on our `\u003CHeader />` component.\n\n```tsx title=\"@/components/header.tsx\" showLineNumbers\nimport { openSidebarAtom } from \"@/atoms/sidebar\";\n\nimport { useSetAtom } from \"jotai\";\nimport { MenuIcon } from \"lucide-react\";\n\nexport function Header() {\n  const openSidebar = useSetAtom(openSidebarAtom);\n  return (\n    \u003Cheader>\n      // other content might be here\n      \u003Cbutton onClick={openSidebar}>\n        \u003CMenuIcon />\n      \u003C/button>\n    \u003C/header>\n  );\n}\n```\n\n### 2. String Recipes\n\nA string recipes usually a `read-only` atoms. Where you take a string atom to be transformed into a new string value.\n\nThis is very helpful whenever I work with string values, for example, lowercase string, [encoding strings to URI components](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent \"Encoding URI Component\"), and so on.\n\n```ts title=\"@/atoms/string.ts\" showLineNumbers\nimport type { PrimitiveAtom } from \"jotai\";\n\nexport function upperCaseAtom(stringAtom: PrimitiveAtom\u003Cstring>) {\n  return atom((get) => get(stringAtom).toUpperCase());\n}\n\nexport function lowerCaseAtom(stringAtom: PrimitiveAtom\u003Cstring>) {\n  return atom((get) => get(stringAtom).toUpperCase());\n}\n```\n\nEncoding a string to URI components.\n\n```ts title=\"@/atoms/string.ts\" showLineNumbers\nimport type { PrimitiveAtom } from \"jotai\";\n\nexport function encodeURIAtom(stringAtom: PrimitiveAtom\u003Cstring>) {\n  return atom((get) => encodeURIComponent(get(stringAtom)));\n}\n```\n\n### 3. Number Recipes\n\nManipulating numbers with atoms is such ease. First, let's start with basic math.\n\n```ts title=\"@/atoms/number.ts\" showLineNumbers\nimport type { PrimitiveAtom } from \"jotai\";\n\nexport function addAtom(numberAtom: PrimitiveAtom\u003Cnumber>) {\n  return atom((get) => get(numberAtom) + 1);\n}\nexport function multiplyAtom(numberAtom: PrimitiveAtom\u003Cnumber>) {\n  return atom((get) => get(numberAtom) * 2);\n}\nexport function divideAtom(numberAtom: PrimitiveAtom\u003Cnumber>) {\n  return atom((get) => get(numberAtom) / 2);\n}\nexport function minusAtom(numberAtom: PrimitiveAtom\u003Cnumber>) {\n  return atom((get) => get(numberAtom) - 1);\n}\n```\n\nThen the cool thing here is that I can transform a number value into a well-formatted value, like formatting numbers into a currency.\n\n```ts title=\"@/atoms/number.ts\" showLineNumbers\nimport type { PrimitiveAtom } from \"jotai\";\n\nexport function formatNumberAtom(numberAtom: PrimitiveAtom\u003Cnumber>) {\n  return atom((get) => {\n    const fmt = new Intl.NumberFormat(\"en-US\", {\n      style: \"currency\",\n      currency: \"USD\",\n    });\n    return fmt.format(get(numberAtom));\n  });\n}\n```\n\n### 4. Array Recipes\n\nLet's start with basic array recipes. We have an array containing a list of objects, and the array should be filtered based on user input.\n\n```ts title=\"@/atoms/array.ts\" showLineNumbers\nimport { atom } from \"jotai\";\n\nexport const inputAtom = atom(\"\");\nexport const clearInputAtom = composeAtom(\n  lowerCaseAtom,\n  noSpaceStringAtom\n)(inputAtom);\nexport const foodsAtom = atom([]);\nexport const filteredFoodsAtom = atom((get) => {\n  const search = get(clearInputAtom);\n  const foods = get(foodsAtom);\n\n  if (search === \"\") return foods;\n  return foods.filter((food) => {\n    return food.name\n      .toLowerCase()\n      .replace(/\\s+/g, \"\")\n      .includes(search.toLowerCase().replace(/\\s+/g, \"\"));\n  });\n});\n```\n\nThat being said, the `filteredFoodsAtom` will filter out the `foodsAtom` based on the `inputAtom` value the user provided.\n\nWait, I can actually create a `pure function` to clear the string.\n\n```ts title=\"@/util/clearstring\"\nexport const clearString = (s: string) => s.toLowerCase().replace(/\\s+/g, \"\");\n```\n\nNow, let's refactor our `filteredFoodsAtom`.\n\n```ts {12-16} title=\"@/atoms.ts\" showLineNumbers\nimport { clearString } from \"@/utils/clearString\";\n\nimport { atom } from \"jotai\";\n\nexport const inputAtom = atom(\"\");\nexport const foodsAtom = atom([]);\nexport const filteredFoodsAtom = atom((get) => {\n  const search = get(inputAtom);\n  const foods = get(foodsAtom);\n\n  if (search === \"\") return foods;\n  return foods.filter((food) => {\n    const clearSearch = clearString(search);\n    const clearName = clearString(food.name);\n    return clearName.includes(clearSearch);\n  });\n});\n```\n\nAnother example is to sort an array; array recipes in Jotai are just like a regular declarative way to mutate your data.\n\nSorting an array of atoms is easy; just like in the previous example, we just need to sort it out.\n\n```ts title=\"@/atoms.ts\" showLineNumbers\nimport { compareDesc } from \"date-fns\";\nimport { atom } from \"jotai\";\n\nexport const postAtoms = atom([]);\n\nexport const latestPostAtoms = atom((get) => {\n  const posts = get(postAtoms);\n\n  return posts.slice(0).sort((a, b) => compareDesc(a, b));\n});\n```\n\nWell that's all I can think of; I probably have used more than those recipes, but I can't remember them. Maybe in another post, thank you for reading this post!","src/content/notes/jotai-recipes.mdx","7259a51287934a74","how-to-setup-husky-nextjs",{"id":91,"data":93,"body":117,"filePath":118,"digest":119,"deferredRender":40},{"title":94,"description":95,"keywords":96,"publishedAt":115,"status":39,"featured":71,"author":116},"How To Setup Husky, Lint Staged, And Commitizen On A Next.js Project","Coding is not just writing lines of code, we often end up do everything manually, so why not use some tools that help us achieve our goals? This article will show you how to setup Husky, Lint Staged, And Conventional Commit With Next.js",[97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114],"husky nextjs","husky lint staged","nextjs husky lint-staged","how to setup husky","how to setup husky lint staged","how to setup nextjs","husky lint staged commitizen","commitizen","commitizen nextjs","commitizen reactjs","conventional commit setup","husky setup","lint staged nextjs","lint staged reactjs","lint staged setup","nextjs reactjs","setup developer experience","setup developer experience nextjs","03/23/2022",{"id":11,"collection":9},"## Introduction\n\nAs a developer, we love to work with Git, a version control system that allows us to keep the code tracked and make sure we don't forget to commit our changes.\n\nBut there is a bit of a problem with Git, when we are working with multiple developers, we often have to merge our changes, and that's where merge conflicts come in, if the conflicts are happen because of our code, we would made change again, but there is some case where the conflicts are caused by just different code style, _single quote vs double quote for example_, aren't it a bit awkward?.\n\n### Git Hooks\n\nLike many other Version Control Systems, Git has a way to fire off custom scripts when certain important actions occur. There are two groups of these hooks: client-side and server-side.\n\nClient-side hooks are triggered by operations such as committing and merging, while server-side hooks run on network operations such as receiving pushed commits. You can use these hooks for all sorts of reasons.\n\nLet's say I have one project with 2 people in it, where we build features on different branches, and when I do commit there are actually type error accoured within the code, and I have no idea why, so the solution is I want to run linter before I commit my changes, and then I can fix the error before I made commit.\n\nBut doing it manually would be a pain, so I want to use a tool that can help me do it for me, so I can just run a script that will run linter before commit has made.\n\n## Husky\n\nWhat is [Husky](https://typicode.github.io/husky)?, from what I get, it said:\n\n> Husky improves your commits and more ðŸ¶ woof!\n\nAs I said before about Git Hooks, we can use these hooks to run custom scripts before certain actions occur, Husky made it more easier to use, and it's a good way to make your life easier.\n\n### Features\n\nHusky offer features to help you, it offer:\n\n- Zero dependencies and lightweight (`6 kB`)\n- Powered by modern new Git feature (`core.hooksPath`)\n- Follows [npm](https://docs.npmjs.com/cli/v7/using-npm/scripts#best-practices) and [yarn](https://yarnpkg.com/advanced/lifecycle-scripts#a-note-about-postinstall) best practices regarding auto install\n- User-friendly messages\n- Optional install\n- Like husky 4, supports\n  - macOS, Linux and Windows\n  - Git GUIs\n  - Custom directories\n  - Monorepos\n\n## Lint Staged\n\n[Lint Staged](https://github.com/okonet/lint-staged) will run linters against staged git files and don't let ðŸ’© slip into your code base!, so when you execcute\nthis command for example, then some script would run\n\n```bash showLineNumbers\n$ git commit\n\nâœ” Preparing lint-staged...\nâ¯ Running tasks for staged files...\n  â¯ packages/frontend/.lintstagedrc.json â€” 1 file\n    â†“ *.js â€” no files [SKIPPED]\n    â¯ *.{json,md} â€” 1 file\n      â ¹ prettier --write\n  â†“ packages/backend/.lintstagedrc.json â€” 2 files\n    â¯ *.js â€” 2 files\n      â ¼ eslint --fix\n    â†“ *.{json,md} â€” no files [SKIPPED]\nâ—¼ Applying modifications from tasks...\nâ—¼ Cleaning up temporary files...\n```\n\n> Linting makes more sense when run before committing your code. By doing so you can ensure no errors go into the repository and enforce code style. But running a lint process on a whole project is slow, and linting results can be irrelevant. Ultimately you only want to lint files that will be committed.\n\n## Conventional Commit With Commitizen\n\nCollaborating with other developer are quiet fun to do, but when you are working with a team, you need to make sure that your code is clean, and that you are following the rules of your team, some are more strict than others, so you need to make sure your commit message are clear and easy to understand.\n\nThat's why we need to use [Commitizen](https://commitizen-tools.github.io/commitizen/) to make sure that your commit message is clear by context and easy to understand by other developer.\n\nCommitizen are very helpful when you want to make a commit, instead of writing your own message, it will prompt you to write your message based on the rules of your team, and based on context, such as `feat`, `fix`, and `chore`.\n\nHere's what it looks like when you run `cz` instead of git commit, it would generate a prompt to help you choose your commit message:\n\n![Commitizen](https://ik.imagekit.io/mlnzyx/attachment/commitizen_Qkfrd4tze.png?ik-sdk-version=javascript-1.4.3&updatedAt=1648026254029 \"Commitizen Prompt on terminal\")\n\n> Tip: click the image to see it more clearly\n\n## Setup Next.js Project\n\nBefore we use any tools, we need to install Next.js and create a new project, simply execute the following command on your terminal:\n\n```bash\nyarn create next-app my-app\n```\n\nIt will spin up a new Next.js project, as usual, you will get a default template created for you, and you can start editing your code there, but in this article I will not teach you how to edit your code, so let's skip that part, and start using the tools we want to use.\n\n## Setup Eslint And Prettier\n\nBefore we continue, the method I'm trying to explain is also use 2 essential tools, which is [eslint](https://eslint.org/) and [prettier](https://prettier.io/).\n\nLet's setup those tools then, we're going to install prettier and eslint then add the config file inside of our project, run the following command on your terminal to install prettier and eslint\n\n```bash\nyarn add prettier -D && npx eslint --init\n```\n\nThe above command will install prettier as your devDependencies and then initialize eslint for your project, you would be asked to some choices, depends on which project you have, if you are using typescript, choose **typescript react**, otherwise javascript react.\n\nEslint will install dependencies for you and then created a config file, if it was `.json` file, consider renaming it to `.js` file and change the code to match to `.js` file instead of `.json`.\n\nNext, create a file at the root of your project and name it with `.prettierrc.js`, and then paste the following config inside of it:\n\n```js title=\".prettierrc.js\" showLineNumbers\nconst config = {\n  semi: false,\n  tabWidth: 2,\n  printWidth: 120,\n  singleQuote: true,\n  jsxSingleQuote: true,\n  trailingComma: \"none\",\n  arrowParens: \"always\",\n  endOfLine: \"auto\",\n};\n\nmodule.exports = config;\n```\n\n> If you are familiar with it, just change the config file to match with your own preference\n\n## Setup Husky\n\nNext, let's install Husky as our Git Hooks, by executing the following command in the terminal:\n\n```bash\nyarn add husky -D\n```\n\nAfter installation completed, run the command to setup husky\n\n```bash\nhusky install\n```\n\nIt will create a new folder at the root of directory which is `/.husky`, open it and create a new file called `pre-commit` inside of `/.husky` directory, then the structure would be like this:\n\n```bash\n/.husky\n/pre-commit\n|- /_\n|-|\n  |- /.gitignore\n  |- /husky.sh\n```\n\nInside `pre-commit` file, paste this code:\n\n```bash title=\".husky/pre-commit\" showLineNumbers\n#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\necho 'ðŸ—ï¸ðŸ‘· Styling your project before committingðŸ‘·â€â™‚ï¸ðŸ—ï¸'\necho 'please be patient, this may take a while...'\n\n# Check ESLint Standards\nyarn lint ||\n(\n    echo 'ðŸ”¨âŒ Yoo, you have a problem in your code. Check linter ðŸ”¨âŒ\n          Run yarn lint, add changes and try commit again.';\n    false;\n)\n\necho 'ðŸŽ‰ No error found: committing this now.... âœ¨ðŸš€ðŸ„â€â™‚ï¸ðŸ»'\n\nnpx lint-staged\n```\n\nThe above code simply will run on your terminal before commit is goint to made by Git, first we printed out 2 paragraphs, and then we run the `yarn lint` command, if the command wasn't successful, then It'll print out the _*ðŸ”¨âŒ Yoo, you have...*_ and immediately cancel the rest of the code as we run the `false` code.\n\nIf _*linting*_ was successfully and no error found, then it'll printed out the message and then it run the `npx lint-staged` script, which is going to format our code with prettier.\n\nCreate a new scripts inside `package.json` file, so it will run everytime the project started to install all the dependencies.\n\n```json {5} title=\"./package.json\" showLineNumbers\n{\n  \"name\": \"app name\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"postinstall\": \"husky install\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n## Setup Lint Staged\n\nNext we need to install Lint Staged, and then we need to setup Lint Staged, so we can run lint before commit, and it's very easy to do, just execute the following command in the terminal to install lint staged:\n\n```bash\nyarn add lint-staged -D\n```\n\nAfter the installation, let's start create the configuration for lint-staged, lint staged give you different ways of configuring lint staged:\n\n- `lint-staged` object in your `package.json`\n- `.lintstagedrc` file in JSON or YML format, or you can be explicit with the file extension:\n  - `.lintstagedrc.json`\n  - `.lintstagedrc.yaml`\n  - `.lintstagedrc.yml`\n\nBut this way I want to show you with lint-staged object in package.json, so let's start with that:\n\n```json title=\"./package.json\" {9-12}\n{\n  \"name\": \"app name\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"postinstall\": \"husky install\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"lint-staged\": {\n    \"**/*.{js,jsx,ts,tsx}\": [\n      \"eslint --fix\",\n      \"prettier --config ./.prettierrc.js --write\"\n    ],\n    \"**/*.{css,scss,md,html,json}\": [\n      \"prettier --config ./.prettierrc.js --write\"\n    ]\n  }\n}\n```\n\n## Setup Commitizen\n\nCommitizen help organize commit message, usually when I want to make changes to my code, and start to track what was I did.\n\nThe easiest way to setup Commitizen is by using it's CLI, the first step is to make your repo **Commitizen friendly**, so let's install the commitizen CLI tools, you can install it globally or locally, but I prefer instaling it globally, so let's type the following command in the terminal:\n\n```bash\nyarn global add commitizen\n```\n\nif you are using npm, you could easly install it by typing the following command:\n\n```bash\nnpm install commitizen -g\n```\n\nNext, initialize your project to use the cz-conventional-changelog adapter by typing:\n\n```bash\ncommitizen init cz-conventional-changelog --save-dev --save-exact\n```\n\nOr if you are using Yarn:\n\n```bash\ncommitizen init cz-conventional-changelog --yarn --dev --exact\n```\n\nThe above command does three things for you:\n\n- Installs the `cz-conventional-changelog adapter`\n- Saves it to `package.json`'s dependencies or devDependencies\n- Adds the config.commitizen key to the root of your package.json file as shown here:\n\n```json {13-17} title=\"./package.json\" showLineNumbers\n{\n  \"name\": \"app name\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"postinstall\": \"husky install\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"lint-staged\": {\n    \"**/*.{js,jsx,ts,tsx}\": [\n      \"eslint --fix\",\n      \"prettier --config ./.prettierrc.js --write\"\n    ],\n    \"**/*.{css,scss,md,html,json}\": [\n      \"prettier --config ./.prettierrc.js --write\"\n    ]\n  },\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"cz-conventional-changelog\"\n    }\n  }\n}\n```\n\nAnd now we are ready to use the `cz` command to make a commit, and it will prompt you to choose your commit message!.\n\n## Summary:\n\nWe made it to the end, let's summarize what was done:\n\n- **Husky**\n\n  It will help us to setup Git Hooks easier.\n\n- **Lint Staged**\n\n  It will help us to run a certain task before commiting our code, and it will make sure that our code is clean and well formatted.\n\n- **Commitizen**\n\n  It will help us to organize our commit message, and it will make sure that our commit message is clear and easy to understand.\n\nSo that's all folks, I hope this article help you out to get started, see you next time!","src/content/notes/how-to-setup-husky-nextjs.mdx","e84a5622be0bf84b"]